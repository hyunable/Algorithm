# Linked List


**리스트** 는 배열과 같이 데이터 집합을 보관하는 기능을 갖지만 *<u>유연하게 크기를 바꿀 수 있는 자료구조</u>* 이다.

**링크드 리스트(Linked List)** 는 리스트를 구현하는 여러 가지 기법 중에서도 가장 간단한 방법으로 꼽히는 자료구조이다.



<br>



## 노드(Node)

---

리스트를 이루는 요소를 뜻한다. 데이터와 다음 노드에 대한 주솟값을 가리키는 포인터로 이루어져 있다.



![node](http://btechsmartclass.com/DS/images/LL%20Node.png)



<br>

이 노드들을 사슬처럼 엮으면 **링크드 리스트**가 된다.

![node](https://qph.fs.quoracdn.net/main-qimg-9c72477fc5e5a40af33662e5f3682178)

리스트의 가장 앞에 있는 노드를 **헤드(head)** , 가장 마지막에 있는 노드를 **테일(tail)** 이라고 한다.



<br>



## 링크드 리스트의 주요 연산

- 노드 생성/소멸
- 노드 추가
- 노드 탐색
- 노드 삭제
- 노드 삽입



<br>



### 노드생성/소멸

---

C/C++ 언어로 작성된 프로그램은 세 가지 메모리 영역을 가진다. 

- 정적 메모리(Static Memory) : 전역 변수, 정적 변수 등이 저장되는 메모리. 프로그램이 종료될 때 해제된다.
- 자동 메모리(Automatic Memory) : 지역 변수가 저장되는 메모리. 코드블록이 종료되면 해제된다.
- 자유 저장소(Free store) : 프로그래머가 직접 관리하는 메모리 영역. 할당 및 해제를 해주어야 한다.



<br>



### 노드 추가

---

노드 추가 연산은 링크드 리스트의 테일 노드 뒤에 새로운 노드를 만들어 연결하는 것을 의미한다.



<br>



### 노드 탐색

---

탐색 연산은 링크드 리스트가 갖고 있는 약점 중의 하나이다. 리스트는 인덱스를 통해 원하는 요소를 즉시 뽑아낼 수 있는 반면, 링크드 리스트는 헤드부터 하나씩 검색하여 찾아야 하기 때문이다. 



<br>



### 노드 삭제 

---

노드 삭제 연산은 링크드 리스트 내에 있는 임의의 노드를 제거하는 연산이다. 삭제하고자 하는 노드를 찾은 후, 해당 노드의 다음노드를 이전 노드의 `NextNode` 포인터에서 제거하면 된다.(해제)

또한 해당 노드의 이전 노드의 `NextNode`가 해당 노드의 다음 노드를 가리키게 하면 된다. (tail이 아닐 경우)

![removed node](https://www.iro.umontreal.ca/~pift1025/bigjava/Ch20/images/removing_first.png)



<br>



### 노드 삽입

---

노드 삽입은 노드와 노드 사이에 새로운 노드를 끼워넣는 연산이다. 삽입 될 부분에 이전 노드가 삽입 될 노드를 가리키게 하고, 삽입된 노드가 다음 노드를 가리키게 하면 삽입이 된다.



<br>



### 노드 count

---

노드를 Head부터 Tail까지 `Count++` 하며 개수를 센다. 


<br>


### 링크드리스트의 단점
---
- 다음 노드를 가리키는 포인터 때문에 각 노드마다 4byte의 메모리가 추가로 필요하다
- 특정 위치에 있는 노드를 얻는데 드는 비용이 크며 속도도 느리다. (n개일때 최악의 경우 n회 탐색해야함, 반면 list의 경우 인덱싱으로 탐색이 쉽다)


<br>


### 링크드리트스의 장점
---
- 새로운 노드의 추가/삽입/삭제가 쉽고 빠르다. (반면, list는 요소를 삽입하거나 제거하는데 드는 비용이 크다)
- 현재 노드의 다음 노드를 얻기 위한 비용이 발생하지 않는다.
